{
  "label": "junos_protocols.jinja",
  "text": "{% set vrf_vlan = property_sets.get('vrf_vlan', {}) %}\n{% set prot_prop = property_sets.get('protocol_properties', {} ) %}\n{% set sys_prop = property_sets.get('custom_sys_properties', {} ) %}\n{% set ns = namespace ( ) %}\n{% set ns.neighbor_asn = None %}\n{% set ns.neighbor_loopback = None %}\n{% set ns.dev_vlan_list = [ ] %}\n{% set ns.global_vlan_list = [ ] %}\n{% set ns.nameserver_list = [ ] %}\n{% set ns.dot1x_if_list = [ ] %}\n{% set ns.vrf_uses_dhcp_relay = False %}\n{% for server in sys_prop.dns.servers %}\n    {{ns.nameserver_list.append( server ) or '' }}\n{% endfor %}\n{% set vlan_list = [] %}\n{# Compute a Junos-friendly loopback address from what resource generator created #}\n{% set loopback_prefix = function.get_resource_value(resources, 'loopback_assignments', 'fabric_resources', 'devices') %}\n{% if loopback_prefix != '' %}\n    {% if loopback_prefix|to_netmask == 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff' \n       or loopback_prefix|to_netmask == 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:fffe' %}\n        {% set loopback_ipv6 = loopback_prefix|to_ip %}\n    {% else %}\n        {% set loopback_ipv6 = loopback_prefix|replace( '::/', '::1/')|to_ip %}\n    {% endif %}\n{% endif %}\n{% set local_asn = function.get_resource_value(resources, 'asn_assignments', 'fabric_resources', 'devices') %}\n{% for vlan in vrf_vlan.vlans %}\n    {{ ns.global_vlan_list.append(vlan['vlan_name']) or \"\" }}\n{%- endfor %}\n{% for interface_name, iface in interfaces.items() %}\n    {% if 'mode_trunk' in iface.link_tags or 'mode_access' in iface.link_tags %}\n        {% for vlan in ns.global_vlan_list %}\n            {% if vlan in iface.link_tags %}\n                {{ ns.dev_vlan_list.append(vlan) or '' }}\n            {% endif %}\n        {% endfor%}\n    {% endif %}\n{% endfor %}\n\nreplace: protocols {\n{% if 'enabled' in sys_prop.dot1x and sys_prop.dot1x.enabled %}\n    dot1x {\n        authenticator {\n            authentication-profile-name {{ sys_prop.dot1x.auth_profile_name }};\n    {% for interface_name, iface in interfaces.items() %}\n        {% if ('mode_trunk' in iface.link_tags or\n            'mode_access' in iface.link_tags) and\n            'dot1x' in iface.link_tags -%}\n            {{ ns.dot1x_if_list.append(iface['name']) or '' }}\n        {%- endif %}\n    {% endfor %}\n    {%if ns.dot1x_if_list != '' %}\n            interface {\n        {% for if_name in ns.dot1x_if_list %}\n                {{ if_name }}.0 {\n                    supplicant {{ sys_prop.dot1x.supplicant }};\n            {% if 'auth_mode' in sys_prop.dot1x and\n                sys_prop.dot1x.auth_mode == 'mac-radius' %}\n                    mac-radius;\n            {% endif %}\n                }\n        {% endfor %}\n            }\n    {% endif %}\n        }\n    }\n{% endif %}\n    router-advertisement {\n{% for interface_name, iface in interfaces.items() %}\n    {% if iface['ipv6_address'] and iface['ipv6_prefixlen'] %}\n        interface {{ interface_name }}.0 {\n            max-advertisement-interval {{ prot_prop.router_advertisement.max_adv_int }};\n            min-advertisement-interval {{ prot_prop.router_advertisement.min_adv_int }};\n        }\n    {% endif %}\n{% endfor %}\n{% if ns.dev_vlan_list %}\n    {% for vlan in vrf_vlan.vlans %}\n        {% set ns.vrf_uses_dhcp = False %}\n        {% if vlan['vlan_name'] in ns.dev_vlan_list and\n              vlan['irb_gateway6'] %}\n            {% set irb_prefix = [ vlan['irb_gateway6'], vlan['ipv6_prefix_len'] ]|join('/')|to_network %}\n            {% for vrf in vrf_vlan.vrfs %}\n                {% if ( (vlan['member_of'] == vrf['vrf_name'] and\n                         vrf['dhcp6_mode'] == 'relay' ) or\n                        vrf['dhcp6_mode'] == 'server' ) %}\n                    {% set ns.vrf_uses_dhcp = True %}\n                {% endif %}\n            {% endfor %}\n\n        interface irb.{{ vlan['vlan_id'] }} {\n            max-advertisement-interval {{ prot_prop.router_advertisement.max_adv_int }};\n            min-advertisement-interval {{ prot_prop.router_advertisement.min_adv_int }};\n            {% if ns.vrf_uses_dhcp %}\n            managed-configuration;\n            other-stateful-configuration;\n            {% else %}\n            no-managed-configuration;\n            no-other-stateful-configuration;\n            {% endif %}\n            {% for server in ns.nameserver_list %}\n            dns-server-address {{ server }} {\n                lifetime {{ prot_prop.router_advertisement.rdnss_lifetime }};\n            }\n            {% endfor %}\n            prefix {{ irb_prefix }}/{{ vlan['ipv6_prefix_len'] }} {\n                preferred-lifetime {{ prot_prop.router_advertisement.prefix_pref_lifetime }};\n                valid-lifetime {{ prot_prop.router_advertisement.prefix_val_lifetime }};\n                on-link;\n            {% if 'is_slaac' in prot_prop.router_advertisement and\n                  prot_prop.router_advertisement.is_slaac %}\n                autonomous;\n            {% else %}\n                no-autonomous;\n            {% endif %}\n            }\n        }\n        {% endif %}\n    {% endfor %}\n{% endif %}\n    }\n{% if 'onlink_subnet_only' in prot_prop.neighbor_discovery and \n    prot_prop.neighbor_discovery.onlink_subnet_only %}\n    neighbor-discovery {\n        onlink-subnet-only;\n    }\n{% endif %}\n    l2-learning {\n        telemetry {\n            enable-remote-entries;\n        }\n    }\n    lldp {\n        port-id-subtype interface-name;\n        port-description-type interface-description;\n        neighbour-port-info-display port-id;\n        interface all;\n    }\n{% if 'sflow' in prot_prop and prot_prop.sflow.enabled %}\n    sflow {\n        polling-interval {{ prot_prop.sflow.polling_interval }};\n    {% if 'mgt_prefix_v6' in sys_prop and sys_prop.mgt_prefix_v6 != '' and\n          'source_v6_supported' in prot_prop.sflow and\n          prot_prop.sflow.source_v6_supported %}\n        {% set mgt_prefix_v6 = sys_prop.mgt_prefix_v6|to_network %}\n        source-ip inet6 {{ mgt_prefix_v6 }}{{ management_ip }};\n    {% else %}\n        source-ip {{ management_ip }};\n    {% endif %}\n        sample-rate {\n            ingress {{ prot_prop.sflow.ingress_sample_rate }};\n            egress {{ prot_prop.sflow.egress_sample_rate }};\n        }\n    {% if 'collector4' in prot_prop.sflow and prot_prop.sflow.collector4 != '' %}\n        {% for collector in prot_prop.sflow.collector4 %}\n        collector {{ collector['host_ip'] }} {\n            udp-port {{ collector['udp_port'] }};\n        }\n        {% endfor %}\n    {% endif %}\n    {% if 'collector6' in prot_prop.sflow and\n            prot_prop.sflow.collector6 != '' and\n            prot_prop.sflow.source_v6_supported %}\n        {% for collector in prot_prop.sflow.collector6 %}\n        collector {{ collector['host_ip'] }} {\n            udp-port {{ collector['udp_port'] }};\n        }\n        {% endfor %}\n    {% endif %}\n    {% for interface_name, iface in interfaces.items() %}\n        {% if iface['role'] == 'external' and iface['if_type'] == 'ethernet' %}\n        interfaces {{ iface['name'] }}.0;\n        {% endif %}\n    {% endfor %}\n    }\n{% endif %}\n    rstp {\n        bridge-priority 0;\n        bpdu-block-on-edge;\n{% for interface_name, iface in interfaces.items() %}\n    {% if 'mode_trunk' in iface.link_tags or 'mode_access' in iface.link_tags %}\n        interface {{ interface_name }} {\n            edge;\n        }\n    {% endif %}\n{% endfor %}\n    }\n    bgp {\n        log-updown;\n        graceful-restart;\n{% if 'leaf' in system_tags %}\n        group l3clos-l {\n            type external;\n            family inet6 {\n                unicast;\n            }\n            export ( LEAF_TO_SPINE_FABRIC_OUT && BGP-AOS-Policy );\n            multipath {\n                multiple-as;\n            }\n            bfd-liveness-detection {\n                minimum-interval {{ prot_prop.bgp.bfd_min_int }};\n                multiplier {{ prot_prop.bgp.bfd_multiplier }};\n            }\n            vpn-apply-export;\n    {% for interface_name, iface in interfaces.items() %}\n        {% if not iface.get('ipv6_address') %}\n            {% continue %}\n        {% endif %}\n        {% set neighbor_interfaces = iface.get('neighbor_interfaces', []) %}\n        {% for neighbor_interface in neighbor_interfaces if neighbor_interface.get('ipv6_address') %}\n\t\t    {% set ns.neighbor_asn = function.get_resource_value(all_resources.get(neighbor_interface.system_id), 'asn_assignments', 'fabric_resources', 'devices') %}\n            neighbor {{ neighbor_interface.ipv6_address }} {\n                peer-as {{ ns.neighbor_asn }};\n            }\n        {% endfor %}\n    {% endfor %}\n        }\n        group l3clos-l-evpn {\n            type external;\n            multipath {\n                multiple-as;\n            }\n            multihop {\n                no-nexthop-change;\n                ttl 1;\n            }\n            family evpn {\n                signaling {\n                    loops 2;\n                }\n            }\n            bfd-liveness-detection {\n                minimum-interval {{ prot_prop.bgp.bfd_min_int }};\n                multiplier {{ prot_prop.bgp.bfd_multiplier }};\n            }\n            vpn-apply-export;\n            local-address {{ loopback_ipv6 }};\n            export ( LEAF_TO_SPINE_EVPN_OUT && EVPN_EXPORT )\n    {% for interface_name, iface in interfaces.items() %}\n        {% if not iface.get('ipv6_address') %}\n            {% continue %}\n        {% endif %}\n        {% set neighbor_interfaces = iface.get('neighbor_interfaces', []) %}\n        {% for neighbor_interface in neighbor_interfaces if neighbor_interface.get('ipv6_address') %}\n\t\t    {% set ns.neighbor_asn = function.get_resource_value(all_resources.get(neighbor_interface.system_id), 'asn_assignments', 'fabric_resources', 'devices') %}\n\t\t    {% set ns.neighbor_loopback = function.get_resource_value(all_resources.get(neighbor_interface.system_id), 'loopback_assignments', 'fabric_resources', 'devices') %}\n                {% if ns.neighbor_loopback|to_netmask == 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff'\n                   or ns.neighbor_loopback|to_netmask == 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:fffe' %}\n                    {% set peer_ipv6 = ns.neighbor_loopback|to_ip %}\n                {% else %}\n                    {% set peer_ipv6 = ns.neighbor_loopback|replace( '::/', '::1/' )|to_ip %}\n                {% endif %}\n            neighbor {{ peer_ipv6 }} {\n                peer-as {{ ns.neighbor_asn }};\n            }\n        {% endfor %}\n    {% endfor %}\n        }\n{% endif %}\n{% if 'spine' in system_tags %}\n        group l3clos-s {\n            type external;\n            family inet6 {\n                unicast;\n            }\n            export ( SPINE_TO_LEAF_FABRIC_OUT && BGP-AOS-Policy );\n            multipath {\n                multiple-as;\n            }\n            bfd-liveness-detection {\n                minimum-interval {{ prot_prop.bgp.bfd_min_int }};\n                multiplier {{ prot_prop.bgp.bfd_multiplier }};\n            }\n            vpn-apply-export;\n    {% for interface_name, iface in interfaces.items() %}\n        {% if not iface.get('ipv6_address') %}\n            {% continue %}\n        {% endif %}\n        {% set neighbor_interfaces = iface.get('neighbor_interfaces', []) %}\n        {% for neighbor_interface in neighbor_interfaces if neighbor_interface.get('ipv6_address') %}\n\t\t    {% set ns.neighbor_asn = function.get_resource_value(all_resources.get(neighbor_interface.system_id), 'asn_assignments', 'fabric_resources', 'devices') %}\n            neighbor {{ neighbor_interface.ipv6_address }} {\n                peer-as {{ ns.neighbor_asn }};\n            }\n        {% endfor %}\n    {% endfor %}\n        }\n        group l3clos-s-evpn {\n            type external;\n            multipath {\n                multiple-as;\n            }\n            multihop {\n                no-nexthop-change;\n                ttl 1;\n            }\n            family evpn {\n                signaling;\n            }\n            bfd-liveness-detection {\n                minimum-interval {{ prot_prop.bgp.bfd_min_int }};\n                multiplier {{ prot_prop.bgp.bfd_multiplier }};\n            }\n            vpn-apply-export;\n            local-address {{ loopback_ipv6 }};\n            export ( LEAF_TO_SPINE_EVPN_OUT )\n    {% for interface_name, iface in interfaces.items() %}\n        {% if not iface.get('ipv6_address') %}\n            {% continue %}\n        {% endif %}\n        {% set neighbor_interfaces = iface.get('neighbor_interfaces', []) %}\n        {% for neighbor_interface in neighbor_interfaces if neighbor_interface.get('ipv6_address') %}\n\t\t    {% set ns.neighbor_asn = function.get_resource_value(all_resources.get(neighbor_interface.system_id), 'asn_assignments', 'fabric_resources', 'devices') %}\n\t\t    {% set ns.neighbor_loopback = function.get_resource_value(all_resources.get(neighbor_interface.system_id), 'loopback_assignments', 'fabric_resources', 'devices') %}\n                {% if ns.neighbor_loopback|to_netmask == 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff'\n                   or ns.neighbor_loopback|to_netmask == 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:fffe' %}\n                    {% set peer_ipv6 = ns.neighbor_loopback|to_ip %}\n                {% else %}\n                    {% set peer_ipv6 = ns.neighbor_loopback|replace( '::/', '::1/' )|to_ip %}\n                {% endif %}\n            neighbor {{ peer_ipv6 }} {\n                peer-as {{ ns.neighbor_asn }};\n            }\n        {% endfor %}\n    {% endfor %}\n        }\n{% endif %}\n    }\n}\n{# EOF #}"
}